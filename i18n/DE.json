{
	"IMPRESS": "Impressum",
	"LOGIN": "Anmelden",
	"LOGOUT": "Abmelden",
	"BOOKTAB": "Buch",
	"HOME": "Startseite",
	"USERACCOUNT": "Benutzerkonto",
	"CONTACT": "Kontakt",
	"MODULELANGUAGES": "Formale Sprachen",
	"MODULEKFGEDIT": "Kontextfreie Grammatiken",
	"MODULEREGEXPEDIT": "Reguläre Ausdrücke",
	"MODULEAUTOEDIT": "Abstrakte Automaten",
	"MODULETDIAG": "Compiler und Interpreter",
	"EXAMPLECOLLECTION": "Beispielsammlung",
	"ADMINISTRATION": "Admin",
	"SEARCH": "Suchen",
	"CANCEL": "Abbrechen",
	"SAVE": "Speichern",
	"OK": "OK",
	"YES": "Ja",
	"NO": "Nein",
	"DELETE": "Löschen",
	"FOLDER": "Ordner",
	"NEWFOLDER": "Neuer Ordner",
	"FOLDERNAME": "Ordnername",
	"PUBLISH": "Veröffentlichen",
	"MAKECOPY": "Arbeitskopie erstellen",
	"PUBLICCOLLECTION": "Öffentliche Sammlung",
	"FORGOTPASSWORD": "Passwort vergessen?",
	"EMAIL": "E-Mail",
	"PASSWORD": "Passwort",
	"PASSWORDREPEAT": "Wiederholung",
	"NEWPASSWORD": "Neues Passwort",
	"SAVEPASSWORD": "Passwort speichern",
	"RESETPASSWORD": "Passwort zurücksetzen",
	"PASSWORDNOW": "Aktuelles Kennwort",
	"REGISTERNEW": "Konto eröffnen",
	"REGISTER": "Registrieren",
	"CHANGEEMAIL": "Emailadresse ändern",
	"CHANGEPROFILE": "Profildaten ändern",
	"CHANGEPASSWORD": "Passwort ändern",
	"NAME": "Name",
	"SURNAME": "Nachname",
	"ALPHABET": "Alphabet",
	"ALPHABETS": "Alphabete",
	"HINT": "Hinweis",
	"DESCRIPTION": "Beschreibung",
	"RESULT": "Ergebnis",
	"ERROR": "Fehler",
	"UNDO": "Letzte Änderung rückgängig machen",
	"REDO": "Letzte Änderung wiederherstellen",
	"LASTCHANGE": "Letzte Änderung",
	"ABOUT": {
		"FLACI": "Was ist FLACI?",
		"FLACITEXT": "FLACI (von engl. Formal Languages, Automata, Compilers and Interpreters) ist eine Lernumgebung im Bereich der theoretischen Informatik, speziell der Automatentheorie, der formalen Sprachen und deren Anwendung im Compilerbau. FLACI fördert Aktivitäten zur Aneignung von Abstraktionstechniken, wie sie bei professioneller Softwareentwicklung und beim Einsatz komplexer Programmierkonzepte erforderlich sind.",
		"FLACIREF": "FLACI ist ein Kooperationsprojekt der <a href=\"http://www.hszg.de/\" target=\"_blank\">Hochschule Zittau/Görlitz</a> und der <a href=\"http://www.phsz.ch/\" target=\"_blank\">Pädagogischen Hochschule Schwyz</a>.",
		"FLACIBASE": "Das Projekt basiert auf dem Desktop-Werkzeug <a href=\"http://atocc.de/\" target=\"_blank\">AtoCC</a> aus dem Jahr 2012.",
		"FLACIAUTHORS": "Projektleitung: <a href=\"https://www.phsz.ch/forschung/institut-fuer-medien-und-schule/michael-hielscher/\" target=\"_blank\">Dr. Michael Hielscher</a> und <a href=\"https://www.hszg.de/f-ei/fakultaet/professoren/christian-wagenknecht\" target=\"_blank\">Prof. Dr. Christian Wagenknecht</a>",
		"FLACISTUDENTS": "Studentische Mitarbeiter/innen (in alphabetischer Reihenfolge)",
		"FLACISTUDENTLIST": "Stefan Bradl, Ronald Krause, Dana Müller, Alexander Preuß, Robert Rosenberger, Tobias Salzmann, Robert Stricker, Ralf Zücker",
		"FLACILIBS": "Verwendete Bibliotheken"
	},
	"BOOK": {
		"AUTHORS": "Autor(en): Wagenknecht, Christian / Hielscher, Michael",
		"TITLE": "Formale Sprachen, abstrakte Automaten und Compiler",
		"SUBTITLE": "Lehr- und Arbeitsbuch für Grundstudium und Fortbildung",
		"CONTENT": "Inhalt",
		"CONTENTTEXT1": "Die eher abstrakten Inhalte der Theoretischen Informatik werden aus praktischen Anwendungsbeispielen heraus motiviert, anschaulich vermittelt und in Übungen vertieft. Durch das gesamte Buch hindurch zieht sich das Vorhaben, einen Compiler für eine Sprache mit grafischen Effekten herzustellen. Die dafür notwendigen Beiträge werden schrittweise erarbeitet und Aspekte automatisierter Compilergenerierung werden thematisiert.",
		"CONTENTTEXT2": "Zur Modellierung formaler Sprachen, regulärer Ausdrücke, abstrakter Automaten und zur automatisierten Compilergenerierung aus einer grafisch-visuellen Beschreibung stellt AtoCC miteinander vernetzter Komponenten zur Verfügung. Die Lern- und Arbeitsumgebung AtoCC wurde speziell für das Studium der theoretischen Informatik entwickelt und bereits an mehreren Hochschulen und Schulen erfolgreich eingesetzt. AtoCC vertieft Theoriewissen durch praktische Übungen und attraktive Anwendungsprojekte aus dem Grafik- und Audiobereich. Übersetzung und Verarbeitung mehr oder weniger komplexer Sprachen finden wir heute beispielsweise auch in modernen Web-Applikationen.",
		"TOPICS": "Themen",
		"TOPICSTEXT": "Struktur von Programmen – Grundbegriffe – Definition unendlicher Mengen – Sprachübersetzer – Endliche Automaten, reguläre Sprachen und reguläre Ausdrücke – Kellerautomaten und kontextfreie Sprachen – LL(k)-Sprachen – LR(k)-Sprachen – Parser und Parsergeneratoren – Sprachübersetzerprojekt – Mealy- und Moore-Maschinen – Turing-Maschine und Chomsky-Typ-0/1-Sprachen",
		"TARGET": "Zielgruppe",
		"TARGETTEXT": "Studierende der Informatik an Fachhochschulen, Universitäten und Berufsakademien sowie Lehrpersonen an der gymnasialen Oberstufe."
	},
	"LANGUAGES": {
		"ALPHABETANDCHARACTERS": "Alphabet und Zeichen",
		"WORD": "Wort",
		"WORDSET": "Wortmenge",
		"LANGUAGE": "Sprache",
		"DEFALPHABET": "Ein <i>Alphabet A</i> ist eine <i>endliche, nichtleere</i> Menge von <i>Zeichen</i>.",
		"SELECTALPHABET": "Wählen Sie eines der Beispiel-Alphabete zum Experimentieren aus.",
		"CREATESELF": "ist selbst definierbar.",
		"ALHABETCHARS": "Alphabetzeichen (mit Komma getrennt eingeben)",
		"NEXTTOWORD": "Weiter zum Wort",
		"DEFWORD": "Ein <i>Wort w</i> über dem <i>Alphabet A</i> ist eine Zeichenkette, die ausschließlich aus <i>Zeichen</i> aus <i>A</i> besteht. Das <i>leere Wort</i> &epsilon;=\"\" ist ein Wort über jedem beliebigen Alphabet.",
		"BUILDWORDHINT": "Klicken Sie wiederholt auf Zeichen des Alphabets <i>A</i>, um ein Wort <i>w</i> zu konstruieren.",
		"DELETECHARSHINT": "Klicken Sie auf Zeichen von <i>w</i>, um diese zu entfernen.",
		"NEXTTOWORDLENGTH": "Weiter zur Wortmenge",
		"DEFWORDLENGTH": "Die <i>Länge eines Wortes w</i>, kurz: |<i>w</i>|, ist bestimmt durch die Anzahl <i>aller</i> Zeichen, die das Wort enthält. Mehrfachvorkommen werden entsprechend mehrfach gezählt.",
		"WORDLENGTH": "Wortlänge",
		"DEFWORDSET": "Die Menge <i>aller</i> Wörter über <i>A</i> nennt man die <i>Wortmenge A<sup>*</sup></i>.  <i>A<sup>*</sup></i> ist eine <i>abzählbar unendliche</i> Menge und lässt sich systematisch notieren. Das leere Wort <i>&epsilon;</i> gehört zu jeder Wortmenge.",
		"SHOWMOREITEMS": "Weitere Elemente anzeigen",
		"NEXTTOLANGUAGE": "Weiter zur Sprache",
		"DEFLANGUAGE": "Eine <i>Sprache L&sube;A<sup>*</sup></i> ist eine beliebige Menge von Wörtern über <i>A</i>. Eine Sprache <i>L</i> kann somit eine endliche oder eine abzählbar unendliche Menge sein.",
		"BUILDLANGUAGEHINT": "Stellen Sie eine Sprache <i>L</i> durch Anklicken einzelner <i>Wörter</i> aus <i>A<sup>*</sup></i> zusammen.",
		"DEFLANGUAGELIMITS": "Praxisrelevante Sprachen sind im Allgemeinen abzählbar unendliche Mengen. Wie kann man sie als Teilmengen der zugehörigen Wortmenge definieren?",
		"ALTERNATIVEHINT": "Einige der abzählbaren Sprachen (endl., unendl.) können zum Beispiel auch folgendermaßen festgelegt werden",
		"ALLWORDSSTARTINGWITH": "<i>L<sub>1</sub></i> = alle Wörter aus <i>A<sup>*</sup></i>, die mit",
		"ALLWORDSSTARTINGWITHEND": "beginnen.",
		"ALLWORDSSHORTERTHEN": "<i>L<sub>2</sub></i> = alle Wörter aus <i>A<sup>*</sup></i>, mit einer Wortlänge kleiner gleich",
		"ALLWORDSSHORTERTHENEND": ".",
		"ALLWORDSCONTAINING": "<i>L<sub>3</sub></i> = alle Wörter aus <i>A<sup>*</sup></i>, die das Wort",
		"ALLWORDSCONTAININGEND": "enthalten.",
		"ALLWORDSSAMEAMOUNT": "<i>L<sub>4</sub></i> = alle Wörter aus <i>A<sup>*</sup></i>, die gleich viele",
		"ALLWORDSSAMEAMOUNTAND": "und",
		"ALLWORDSSAMEAMOUNTEND": "enthalten."
	},
	"KFGEDIT": {
		"GRAMMAR": "Grammatik",
		"SHOWDERIVATIONLIST": "Satzformliste anzeigen",
		"CREATENEWGRAMMAR": "Neue Grammatik erstellen",
		"EDITGRAMMAR": "Grammatik bearbeiten",
		"PUBLISHTO": "Grammatik veröffentlichen in",
		"HASSTILLERRORS": "Die Grammatik enthält noch Fehler.",
		"ISLEFTREGULAR": "Die Grammatik ist linkslinear.",
		"ISRIGHTREGULAR": "Die Grammatik ist rechtslinear.",
		"ISNOTREGULAR": "Die Grammatik ist nicht regulär.",
		"CANNOTTRANSORMWITHOUTREGULAR": "Die Grammatik ist nicht regulär und kann deshalb nicht umgewandelt werden.",
		"TOOMANYTREES": "Für das Wort <b>{{INPUT}}</b> gibt es mehrere oder sogar unendlich viele Ableitungsbäume. Es wird nur ein möglicher Baum generiert.",
		"DERIVEERROR": "Das Wort <b>{{INPUT}}</b> konnte nicht abgeleitet werden.",
		"DELETEGRAMMAR": "Grammatik löschen?",
		"DELETEGRAMMARASK": "Möchten Sie die Grammatik {{NAME}} wirklich löschen?",
		"MYGRAMMARS": "Meine Grammatiken",
		"PRODUCTIONS": "Produktionsregeln",
		"HOWTO": "<b>So definiert man eine Grammatik in FLACI:</b><br><ul><li>Man notiert nur die Produktionsregeln.</li><li>Nach Vereinbarung ist das Nichtterminal auf der linken Seite der zuerst angegebenen Regel das Spitzensymbol der Grammatik</li><li>Für &epsilon; in &epsilon;-Regeln ist EPSILON zu schreiben:<br> S -&gt; a | EPSILON</li><li>Die Pünktchenotation hilft den Schreibaufwand zu reduzieren: <br>a ... z | 0 ... 9.</li><li>Terminale mit Leerzeichen müssen in ' ' geschrieben werden.</li><li>Eine Beispielgrammatik für Palindrome über {a,b}*:<br> S -&gt;  a | b | EPSILON | a S a | b S b </li></ul>",
		"VALIDGRAMMAR": "Gültige Grammatik",
		"DIAGRAMMODE": "Syntax-Diagramm",
		"TEXTMODE": "Textmodus",
		"FULLGRAMMAR": "Vollständige Grammatik",
		"RENAMENONTERMINAL": "Nichtterminal umbenennen",
		"OLDNONTERMINAL": "Bisheriges Nichtterminal",
		"NEWTERMINAL": "Neues Terminal",
		"NEWNONTERMINAL": "Neues Nichtterminal",
		"DERIVE": "Ableiten",
		"RANDOMWORD": "Zufallswort aus L(G) als Eingabe generieren",
		"SINGLESTEP": "Einzelschrittmodus",
		"LEFTRIGHTDERIVATION": "Links-/Rechtsableitung",
		"CHECK": "Prüfen",
		"TRANSFORMATIONS": "Transformieren",
		"TREESELECT": "Ableitungsbaum {{INDEX}} von {{TOTAL}}",
		"SATZFORM": "Satzform",
		"SATZFORMLIST": "Satzformliste",
		"USEDRULE": "Angewandte Regel",
		"CONVERTS": "Konvertieren",
		"CONVERT": {
			"TOREGEX": "rG in Regulären Ausdruck",
			"TOREGEXHINT": "Konvertiert eine reguläre Grammatik in einen äquivalenten regulären Ausdruck",
			"TONEA": "rG in NEA",
			"TONEAHINT": "Konvertiert eine reguläre Grammatik in einen äquivalenten nichtdeterministischen endlichen Automaten",
			"TONKA": "kfG in NKA",
			"TONKAHINT": "Konvertiert eine kontextfreie Grammatik in einen äquivalenten nichtdeterministischen Kellerautomaten",
			"DOWNLOADSYNTAXPNG": "Syntaxdiagramm als PNG",
			"DOWNLOADDERIVATIONPNG": "Ableitungsbaum als PNG"
		},
		"TRANSFORM": {
			"CHECKLL1": "LL(1) Grammatik?",
			"CHECKLL1HINT": "<ul>\n<li>Forderung 1: Die FIRST-Mengen der Satzformen auf den rechten Seiten der Ersetzungsregeln je eines Nichtterminals müssen paarweise disjunkt sein.</li>\n<li>Forderung 2: Die FIRST-Menge und FOLLOW-Menge jedes Nichtterminals, das zu ɛ ableitbar ist, müssen disjunkt sein.</li>\n</ul>",
			"ISREGULAR": "Reguläre Grammatik?",
			"ISREGULARHINT": "Prüft, ob sämtliche Produktionsregeln der Grammatik entweder die Form X &rarr; aY (rechtslinear) oder X &rarr; Ya (linkslinear) haben. Außerdem sind terminalerzeugende Regel der Gestalt X &rarr; a zugelassen.",
			"TOCNF": "Chomsky Normalform",
			"TOCNFHINT": "<ul>\n<li>Eine Grammatik in der Chomsky Normalform (CNF) besteht nur aus Regeln für alle Nichtterminale (links) deren rechte Seiten entweder aus genau einem Terminal oder aus genau zwei Nichtterminalen bestehen.</li>\n<li>ɛ-Regeln entfernen, Kettenregeln entfernen und Grammatik vereinfachen wird automatisch vorgeschaltet.</li>\n<li>Beinhaltet die Sprache das leere Wort wird ein neues Startsymbol festgelegt, welches im Folgenden nicht weiter betrachtet wird.</li>\n<li>Zunächst wird für jedes Terminal x ein neues Nichtterminal X erzeugt, die Regel X &rarr; x ergänzt und in allen Regeln die Vorkommen von x durch X ersetzt.</li>\n<li>Regeln mit mehr als zwei Nichtterminalen auf der rechten Seite werden durch neue Regeln mit neuen Nichtterminalen substituiert, bis nur noch zwei Nichtterminale pro rechte Regelseite übrig bleiben.</li>\n</ul>",
			"INSERTEPSILON": "ε-Regeln hinzufügen",
			"INSERTEPSILONHINT": "<uL>\n<li>Das leere Wort wird der Sprache hinzugefügt.</li>\n<li>Es wird ein neues Startsymbol erzeugt, welches unmittelbar zu ɛ bzw. zum alten Startsymbol übergeht.</li>\n</ul>",
			"REMOVEEPSILON": "ε-Regeln entfernen",
			"REMOVEEPSILONHINT": "<uL>\n<li>Sämtliche ɛ-Regeln für Nichtterminale werden entfernt.</li>\n<li>Für Regeln, die ein solches Nichtterminal auf der rechten Seite enthalten, werden alle Produktionen unter Auslassung des Nichtterminals der Regelmenge hinzugefügt.</li>\n</ul>",
			"SIMPLIFY": "Grammatik vereinfachen",
			"SIMPLIFYHINT": "<ul>\n<li>Nichtterminale die nicht vom Startsymbol erreichbar sind werden entfernt.</li>\n<li>Regeln der Form A -> A werden entfernt.</li>\n<li>Nichtterminale die ausschließlich durch die Regel A -> ɛ definiert sind werden entfernt.</li>\n<li>Mehrfache Vorkommen der gleichen Regel werden entfernt.</li>\n<li>Nichtterminale mit identischen Regeln werden zusammengefasst</li>\n<li>Nichtterminale die Endlosrekursionen enthalten werden entfernt</li></ul>",
			"REMOVELOOPS": "Kettenregeln entfernen",
			"REMOVELOOPSHINT": "<ul>\n<li>Es werden Paare von Nichtterminalen (A,B) gebildet, wobei A zu B abgeleitet werden kann.</li>\n<li>Die Regeln der Ergebnisgrammatik entstehen, indem A alle Regeln von B zugeordnet werden, die nicht aus genau einem Nichtterminal bestehen.</li>\n</ul>",
			"REMOVELEFTREC": "Linksrekursionen entfernen",
			"REMOVELEFTRECHINT": "<ul>\n<li>Nach Entfernung von ɛ-Regeln und Kettenregeln wird die betrachtete kfG mit dem Paull's Algorithmus in eine äquivalente linksrekursionsfreie kfG transformiert.</li>\n</ul>",
			"LEFTFACTOR": "Linksfaktorisierung",
			"LEFTFACTORHINT": "Das längste gemeinsame Präfix &alpha; von Satzformen auf der rechten Regelseite eines betrachteten Nichtterminals X werden \"ausgeklammert\": X &rarr;\t&alpha; X'. X' definiert den jeweiligen Rest der Satzformen hinter &alpha;."
		},
		"LL1": {
			"TITLE": "Überprüfung der LL(1) Forderungen",
			"F1": "Forderung 1",
			"F2": "Forderung 2",
			"F1OK": "Forderung 1 ist erfüllt.",
			"F2OK": "Forderung 2 ist erfüllt.",
			"F1NOTOK": "Forderung 1 ist nicht erfüllt.",
			"F2NOTOK": "Forderung 2 ist nicht erfüllt.",
			"TRUE": "erfüllt",
			"FALSE": "nicht erfüllt",
			"EMPTYFIRST": "Eine leere FIRST-Menge ist nicht erlaubt.",
			"NOEPSILON": "Da ɛ in der FIRST-Menge nicht vorkommt, ist Forderung 2 erfüllt."
		}
	},
	"REGEXPEDIT": {
		"REGEXP": "Regulärer Ausdruck",
		"REGEXPFORL": "Regulärer Ausdruck für L",
		"REGEXP2": "Regulärer Ausdruck für L2",
		"OPENIN": "Öffnen in Reguläre Ausdrücke",
		"COMPAREREGEXP": "Ausdrücke vergleichen",
		"EQUALREGEXP": "Die angegebenen regulären Ausdrücke für L und L2 sind äquivalent.",
		"NOTEQUALREGEXP": "Die angegebenen regulären Ausdrücke für L und L2 sind nicht äquivalent.",
		"GRAMMAR": "Grammatik",
		"SEARCHTEXT": "Eingabewörter",
		"RAILROAD": {
			"TITLE": "Syntax-Diagramm",
			"NONEOF": "Keins von:",
			"ONEOF": "Eins von:",
			"ANYCHARACTER": "beliebiges Zeichen",
			"STARTOFLINE": "Zeilenanfang",
			"ENDOFLINE": "Zeilenende",
			"TIMES": "+ mal",
			"UPTOTIMES": "bis zu {{TIMES}} mal",
			"GROUP": "Klammer {{GROUP}}",
			"REFERENCEGROUP": "Rückwärtsreferenz (Klammer {{GROUP}})"
		},
		"DEFINITION": "Definition",
		"GRAMMARNAME": "Regulärer Ausdruck",
		"EXPERIMENT": "Experimentieren",
		"DEFREGEXP": "Mit <i>regulären Ausdrücken</i> lassen sich <i>reguläre Sprachen</i> besonders kompakt und intuitiv beschreiben. <i>Reguläre Ausdrücke</i> werden beispielsweise in Texteditoren oder auf der Kommandozeile zum Suchen und Filtern verwendet. Sie werden auch zur Validierung von Benutzereingaben in (Web-)Anwendungen eingesetzt.<br>\nIm Bereich \"Compilerbau\" werden wir von regulären Ausdrücken zur Tokendefinition Gebrauch machen.",
		"INTRODUCTION": "Hier verwenden wir <i>reguläre Ausdrücke</i> in verbreiteter Praxisdefinition als Muster für Wörter, die zu einer regulären Sprache gehören.<br>Auf der linken Seite wird immer ein <i>regulärer Ausdruck</i> angegeben, der auf die rechts angegebenen Eingabewörter passt (rot gekennzeichnet) oder nicht. Diese Syntaxanalysetechnik basiert auf <i>pattern matching</i> (Musterabgleich).  <br>Für die durch den regulären Ausdruck beschriebene Sprache L wird zusätzlich ein <i>Syntaxdiagramm</i> angegeben.",
		"DEFSINGLECHARS": "Der einfachste reguläre Ausdruck <i>a</i> steht für ein einzeichiges Wort \"a\", kurz: a. Es besteht aus genau einem Alphabetzeichen a. Der Ausdruck beschreibt die Sprache L = {a}.<br>Reguläre Ausdrücke lassen sich <i>verketten</i>: <i>a</i> gefolgt von <i>b</i>, gefolgt von <i>c</i> wird kurz <i>abc</i> geschrieben.",
		"DEFCLASSES": "Der Ausdruck <i>[abc]</i> ist eine Zeichenklasse und beschreibt eine Menge, aus der genau ein Zeichen beliebig ausgewählt wird.<br>In einer Menge kann jedes einzelne Zeichen nur einmal angegeben werden. Die Reihenfolge spielt keine Rolle: <i>[abc]</i> = <i>[cab]</i>.<br>Achtung: <i>[Handy]</i> würde nicht etwa das Wort Handy erkennen, sondern genau einen einzelnen Buchstaben, nämlich entweder H, a, n, d oder y.",
		"DEFCLASSRANGE": "In Zeichenklassen, wie z. B. <i>[a-z]</i>, <i>[a-zA-F]</i> oder <i>[0-9]</i>, können ganze Bereiche von Zeichen angegeben werden.<br>Das Minus an dieser Position hat damit die Bedeutung einer Aufzählung und muss ggf. am Ende oder Anfang genannt werden, wenn es selbst zur Sprache gehört <i>[abc-]</i>.",
		"DEFALTERNATIVE": "Mit einem senkrechten Strich | werden Alternativen (sprich: \"oder\") zwischen zwei oder mehreren regulären Ausdrücken notiert.<br><i>Katze</i>|<i>Maus</i> beschreibt die Sprache L = {Katze, Maus}. Mehrere Alternativen werden einfach hintereinander geschrieben: <i>aaa</i>|</i>bbb</i>|</i>ccc</i>.<br>Deren Notationsreihenfolge spielt keine Rolle <i>aaa</i>|<i>bbb</i> = <i>bbb</i>|<i>aaa</i>.<br>Wichtig: Die Operation Verkettung hat Vorrang und wird zuerst ausgeführt. Möchten wir dies ändern, müssen wir runde Klammern einsetzen: <i>(Ha</i>|<i>Ma)us</i>.",
		"DEFOPTIONAL": "Mit <i>a?</i> kann ein Ausdruck <i>a</i> als optional gekennzeichnet werden. Er darf in einem passenden Wort höchstens einmal, d.h. einmal oder keinmal, vorkommen.<br>Achtung: Diese Operation hat Vorrang vor der Verkettung. Der Ausdruck <i>Haus?</i> beschreibt somit die Sprache L = {Hau, Haus}.<br>Durch Klammerung lässt sich die Operation auf komplexere Teilausdrücke anwenden: <i>das (blaue|rote )?Tuch</i>.",
		"DEFSTAR": "<i>a*</i> bedeutet, dass ein Ausdruck <i>a</i> beliebig oft (0-mal, 1-mal,  2-mal, ...) unmittelbar aufeinander folgen kann: <i>&epsilon;</i>, <i>a</i> , <i>aa</i>, ....<br>Soll mindestens ein Zeichen a im Wort enthalten sein, kann statt <i>aa*</i> die Kurzform <i>a+</i> verwendet werden.<br>Achtung: Diese Operationen haben Vorrang vor der Verkettung. Der Ausdruck <i>Haus*</i> beschreibt somit die Sprache L = {Hau, Haus, Hauss, Hausss, ...}.<br>Runde Klammern beziehen diese Operation auf komplexere Teilausdrücke. Der reguläre Ausdruck <i>(abc)+</i> beschreibt die Sprache der Form <i>abc</i>, <i>abcabc</i>, <i>abcabcabc</i> usw.",
		"DEFSPECIALCHARS": "Die wichtigsten Schreibweisen für reguläre Ausdrücke sind nun bekannt. Es gibt jedoch noch viele weitere Operationen, die hier nicht betrachtet werden.<br>Sucht man Sonderzeichen, wie *, +, ?, [], (), $, im Wort, so muss ein \\ vorangestellt werden: <i>5\\+3</i>, <i>50\\$</i> usw., um deren spezielle Funktion auszuschalten.<br><br>Es folgen einige Übungsbeispiele zur Konstruktion regulärer Ausdrücke.",
		"RANDOMWORDS": "Zufallswörter aus L generieren",
		"SAVEASGRAMMAR": "in kontextfreie Grammatik konvertieren",
		"SAVEASREGRAMMAR": "in reguläre Grammatik konvertieren",
		"SAVEASNEA": "in endlichen Automaten konvertieren",
		"EXAMPLES": {
			"TEXT1": "Wie ändert sich die beschriebene Sprache, wenn man den regulären Ausdruck <i>a</i> zu <i>ab</i> oder <i>abc</i> verändert?",
			"SAMPLETEXT1": "a\nab\nabc",
			"EXPRESSION1": "a",
			"TEXT2": "Wie sieht ein regulärer Ausdruck aus, der die Sprache der Farbwörter, die man mit den regulären Ausdrücken <i>rot</i>, <i>gelb</i> und <i>blau</i> beschreibt, akzeptiert?",
			"SAMPLETEXT2": "rot\ngrün\nblau\ngelb\nbraun\nlila",
			"EXPRESSION2": "rot|gelb|blau",
			"TEXT3": "Wie könnte ein regulärer Ausdruck aussehen, der alle drei Sätze mit Gelb beschreibt, aber nicht Sätze mit Rot? (Leerzeichen beachten!) ",
			"SAMPLETEXT3": "Gelb ist eine tolle Farbe\nGelb ist eine Farbe\nGelbe Farbe\nRote ist auch eine Farbe\nRote Farbe",
			"EXPRESSION3": "Gelb ist eine (tolle )?Farbe",
			"TEXT4": "Der folgende Ausdruck lässt sich noch mit der <i>a+</i> Schreibweise verkürzen. Wie?",
			"SAMPLETEXT4": "Hallo\nHaaallloo\nHaaaalllloooo",
			"EXPRESSION4": "Haa*ll*oo*",
			"TEXT5": "Durch Verkettung lassen sich mehrere reguläre Ausdrücke aneinanderfügen. Im Beispiel wird somit eine Folge von drei Zeichen gesucht.<br>Wie müssen die Zeichenmengen erweitert werden, damit die zulässigen Wörter auch die Grossbuchstaben R, O und T enthalten dürfen? Geben Sie einen regulären Ausdruck an, der das zuletzt angegebene Eingabewort beschreibt?",
			"SAMPLETEXT5": "rot\ntot\nTor\nRotor",
			"EXPRESSION5": "[rot][rot][rot]",
			"TEXT6": "Der Beispielausdruck beschreibt die Sprache der dreistelligen natürlichen Zahlen. Wie sieht ein regulärer Ausdruck für vierstellige oder fünfstellige Zahlen aus?",
			"SAMPLETEXT6": "111\n222\n234\n1234\n2345\n3456\n7890\n27384",
			"EXPRESSION6": "[0-9][0-9][0-9]",
			"TASK1": "Regulärer Ausdruck für HTML-Farbcodes<br>\n(Es sollen nur 6 stellige Farbcodes akzeptiert werden, die mit einem # beginnen.)",
			"SAMPLETASK1": "#12AFE3\n#0000FF\n#FF0000\n#AAXXXX\n#AD313",
			"TASK2": "Regulärer Ausdruck für Uhrzeiten<br>\n(Es sollen nur gültige Uhrzeiten akzeptiert werden.)",
			"SAMPLETASK2": "12:32\n23:59\n0:00\n26:12\n6:70",
			"TASK3": "Regulärer Ausdruck für deutsche Kfz-Kennzeichen<br>\n(Es sollen alle Kennzeichen akzeptiert werden.)",
			"SAMPLETASK3": "NOL DE 2034\nZI A 23\nB HU 874",
			"TASK4": "Regulärer Ausdruck für gültige E-Mailadressen<br>\n(Es sollen nur gültige E-Mailadressen akzeptiert werden.)",
			"SAMPLETASK4": "mail@google.com.\nhans.muster@post.de\nhans-wurst@stud.edu.org\nmeine.email.de\nhans-wurst@"
		},
		"REFERENCE": {
			"TITLE": "Referenz:",
			"R1": "Matches the single character a",
			"R2": "Matches the sequenz of the characters a b and c in this order",
			"R3": "Matches any of the alternatives specified",
			"R4": "Matches any character between the brackets",
			"R5": "Matches any character NOT between the brackets",
			"R6": "Matches a single digit",
			"R7": "Matches any character not a digit",
			"R8": "Matches at least one n or more occurrences of n",
			"R9": "Matches zero or more occurrences of n",
			"R10": "Matches zero or one occurrences of n",
			"R11": "Matches a single character, except newline or line terminator",
			"R12": "Matches the character [. Always escape special characters!",
			"R13": "Matches a word character",
			"R14": "Matches a non-word character",
			"R15": "Matches a digit",
			"R16": "Matches a non-digit character",
			"R17": "Matches a whitespace character",
			"R18": "Matches a non-whitespace character",
			"R19": "Matches a new line character",
			"R20": "Matches a carriage return character",
			"R21": "Matches a tab character",
			"R22": "Matches 2 to 4 occurrences of n"
		},
		"ISNOTREGULAR": "Der Ausdruck beschreibt keine reguläre Sprache. Umwandlung nicht möglich."
	},
	"AUTOEDIT": {
		"TYPE": "Typ",
		"TYPEDEASHORT": "DEA",
		"TYPENEASHORT": "NEA",
		"TYPEMEALYSHORT": "MEALY",
		"TYPEMOORESHORT": "MOORE",
		"TYPEDKASHORT": "DKA",
		"TYPENKASHORT": "NKA",
		"TYPETMSHORT": "TM",
		"TYPEDEA": "deterministischer endlicher Automat",
		"TYPENEA": "nichtdeterministischer endlicher Automat",
		"TYPEMEALY": "Mealy-Maschine",
		"TYPEMOORE": "Moore-Maschine",
		"TYPEDKA": "deterministischer Kellerautomat",
		"TYPENKA": "nichtdeterministischer Kellerautomat",
		"TYPETM": "deterministische Turingmaschine",
		"SELECTAUTOMATON": "Automat auswählen",
		"SAMEALPHABET": "mit gleichem Alphabet",
		"AUTOMATON": "Automat",
		"ALLOWPARTIAL": "δ als partielle Funktion erlauben",
		"ALLOWPARTIAL2": "δ und λ als partielle Funktionen",
		"ASKREMOVETRAPSTATES": "Fallenzustände (Trap-States) entfernen?",
		"DELTATABLE": "Übergangstabelle",
		"COPYTRANSITIONTABLE": "in die Zwischenablage kopieren",
		"DEFINITION": "Definition",
		"CONVERTS": "Konvertieren",
		"TRANSFORMATIONS": "Transformieren",
		"DEFDEA": "Ein <i>deterministischer endlicher Automat</i>, kurz: DEA (oder EA), ist durch ein 5-Tupel <i>M = (Q,Σ,δ,q&#8320;,E)</i> definiert.<br>\n<br>\nDie verwendeten Symbole haben folgende Bedeutungen:<br>\nQ ... endliche Menge der Zustände<br>\nΣ ... Eingabealphabet<br>\nδ ... totale Überführungsfunktion<br>\n<span style=\"padding-left:2em\"></span> Q x Σ → Q<br>\nq&#8320;... Anfangszustand, q&#8320; ∈ Q<br>\nE ... Menge von Endzuständen, E ⊆ Q<br>\n<br>\nDer Automat akzeptiert bei Erreichen eines Endzustands am Wortende.",
		"DEFNEA": "Ein <i>nichtdeterministischer endlicher Automat</i>, kurz: NEA, ist durch ein 5-Tupel <i>M = (Q,Σ,δ,q&#8320;,E)</i> definiert.<br>\n<br>\nDie verwendeten Symbole haben folgende Bedeutungen:<br>\nQ ... endliche Menge der Zustände<br>\nΣ ... Eingabealphabet<br>\nδ ... partielle Überführungsfunktion<br>\n<span style=\"padding-left:2em\"></span> Q x (Σ ∪ {ε}) → &weierp;(Q)<br>\nq&#8320;... Anfangszustand, q&#8320; ∈ Q<br>\nE ... Menge von Endzuständen, E ⊆ Q<br>\n<br>\nDer Automat akzeptiert bei Erreichen eines Endzustands am Wortende.",
		"DEFMEALY": "Eine <i>Mealy-Maschine</i> ist durch ein 6-Tupel <i>M = (Q,Σ,∆,δ,λ,q&#8320;)</i> definiert.<br>\n<br>\nDie verwendeten Symbole haben folgende Bedeutungen:<br>\nQ ... endliche Menge der Zustände<br>\nΣ ... Eingabealphabet<br>\n∆ ... Ausgabealphabet<br>\nδ ... totale Überführungsfunktion<br>\n<span style=\"padding-left:2em\"></span> Q x Σ → Q<br>\nλ ... totale Ausgabefunktion<br>\n<span style=\"padding-left:2em\"></span> Q x Σ → ∆<br>\nq&#8320;... Anfangszustand, q&#8320; ∈ Q<br>\n<br>\nDie Maschine erzeugt in jedem Übergang eine Ausgabe.",
		"DEFMOORE": "Eine <i>Moore-Maschine</i> ist durch ein 6-Tupel <i>M = (Q,Σ,∆,δ,λ,q&#8320;)</i> definiert.<br>\n<br>\nDie verwendeten Symbole haben folgende Bedeutungen:<br>\nQ ... endliche Menge der Zustände<br>\nΣ ... Eingabealphabet<br>\n∆ ... Ausgabealphabet<br>\nδ ... totale Überführungsfunktion<br>\n<span style=\"padding-left:2em\"></span> Q x Σ → Q<br>\nλ ... totale Ausgabefunktion<br>\n<span style=\"padding-left:2em\"></span> Q → ∆<br>\nq&#8320;... Anfangszustand, q&#8320; ∈ Q<br>\n<br>\nDie Maschine erzeugt in jedem Übergang eine Ausgabe.",
		"DEFDKA": "Ein <i>deterministischer Kellerautomat</i>, kurz: DKA, ist durch ein 7-Tupel<br>\n<i>M = (Q,Σ,Γ,δ,q&#8320;,k&#8320;,E)</i> definiert.<br>\n<br>\nDie verwendeten Symbole haben folgende Bedeutungen:<br>\nQ ... endliche Menge der Zustände<br>\nΣ ... Eingabealphabet<br>\nΓ ... Kelleralphabet<br>\nδ ... partielle Überführungsfunktion,<br>\n<span style=\"padding-left:2em\"></span> Q x (Σ ∪ {ε}) x Γ → Q x Γ<sup>*</sup><br> \nq&#8320;... Anfangszustand, q&#8320; ∈ Q<br>\nk&#8320;... Kellervorbelegungszeichen,<br>\n<span style=\"padding-left:2em\"></span> k&#8320; ∈ Γ und k&#8320; ∉ Σ<br>\nE ... Menge von Endzuständen, E ⊆ Q<br>\n<br>\nDer Automat akzeptiert bei Erreichen eines Endzustands am Wortende. Der dann aktuelle Kellerinhalt spielt keine Rolle.",
		"DEFNKA": "Ein <i>nichtdeterministischer Kellerautomat</i>, kurz: NKA oder KA, ist durch ein 7-Tupel <i>M = (Q,Σ,Γ,δ,q&#8320;,k&#8320;,E)</i> definiert.<br>\n<br>\nDie verwendeten Symbole haben folgende Bedeutungen:<br>\nQ ... endliche Menge der Zustände<br>\nΣ ... Eingabealphabet<br>\nΓ ... Kelleralphabet<br>\nδ ... partielle Überführungsfunktion,<br>\n<span style=\"padding-left:2em\"></span> Q x (Σ ∪ {ε}) x Γ → &weierp;<sub>endl.</sub>(Q x Γ<sup>*</sup>)<br> \nq&#8320;... Anfangszustand, q&#8320; ∈ Q<br>\nk&#8320;... Kellervorbelegungszeichen,<br>\n<span style=\"padding-left:2em\"></span>k&#8320; ∈ Γ und k&#8320; ∉ Σ<br>\nE ... Menge von Endzuständen, E ⊆ Q<br>\n<br>\nDer Automat akzeptiert bei Erreichen eines Endzustands am Wortende. Der dann aktuelle Kellerinhalt spielt keine Rolle.",
		"DEFTM": "Eine <i>deterministische Turingmaschine</i>, kurz: DTM (oder TM), ist durch ein<br> 7-Tupel <i>M = (Q,Σ,Γ,δ,q&#8320;,$,E)</i> definiert.<br>\n<br>\nDie verwendeten Symbole haben folgende Bedeutungen:<br>\nQ ... endliche Menge der Zustände<br>\nΣ ... Eingabealphabet<br>\nΓ ... Bandalphabet, Σ ⊂ Γ<br>\nδ ... partielle Überführungsfunktion,<br>\n<span style=\"padding-left:2em\"></span> Q x Γ → Q x Γ x {L,N,R}<br>\nq&#8320;... Anfangszustand, q&#8320; ∈ Q<br>\n$ ... Bandvorbelegungszeichen,<br>\n<span style=\"padding-left:2em\"></span> $ ∈ Γ und $ ∉ Σ<br>\nE ... Menge von Endzuständen, E ⊆ Q<br>\n<br>\nDer Automat stoppt durch Crash, wenn kein weiterer Übergang möglich ist. Stoppt der Automat in einem Endzustand, wird das Eingabewort akzeptiert. Der dann aktuelle Inhalt auf dem Band spielt keine Rolle.",
		"MYAUTOMATA": "Meine Automaten",
		"CREATENEWAUTOMATON": "Neuen Automaten erstellen",
		"EDITAUTOMATON": "Automat bearbeiten",
		"DELETEAUTOMATON": "Automat löschen?",
		"DELETEAUTOMATONASK": "Möchten Sie den Automat: {{NAME}} wirklich löschen?",
		"PUBLISHTO": "Automat veröffentlichen in",
		"INPUTALPHABET": "Eingabealphabet:",
		"CREATEALPHABET": "selbst erstellen",
		"ALHABETCHARS": "Alphabetszeichen (mit Komma getrennt eingeben)",
		"STACKALPHABET": "Kelleralphabet:",
		"OUTPUTALPHABET": "Ausgabealphabet:",
		"TAPEALPHABET": "Bandalphabet:",
		"STACK": "Keller",
		"TAPE": "Band",
		"INITIALSTACKCHAR": "Kellervorbelegungszeichen",
		"INITIALTAPECHAR": "Bandvorbelegungszeichen",
		"CREATENEWSTATE": "Neuen Zustand erstellen",
		"CREATENEWTRANSITION": "Neuen Übergang erstellen",
		"AUTOLAYOUTGRAPH": "Ausrichten",
		"CHECKAUTOMATON": "Überprüfen",
		"CHECKOK": "Der Automat ist korrekt definiert.",
		"CHECKASKTOCOMPLETE": "Einige Übergänge wurden noch nicht angegeben. Soll der Automat vervollständigt werden?",
		"SELECTALL": "alle",
		"SELECTNONE": "keine",
		"TOPOFSTACK": "Top of Stack",
		"INPUTCHAR": "Eingabezeichen",
		"STACKWORD": "Kellerwort",
		"ADDLABEL": "Label hinzufügen",
		"DELETELABEL": "Label entfernen",
		"INPUT": "Eingabe",
		"OUTPUT": "Ausgabe",
		"READ": "Lese",
		"WRITE": "Schreibe",
		"DIRECTION": "Richtung",
		"LEFT": "Links",
		"RIGHT": "Rechts",
		"NONE": "Keine",
		"DELETETRANSITION": "Übergang entfernen",
		"FINALSTATE": "Endzustand",
		"STARTSTATE": "Startzustand",
		"DELETESTATE": "Zustand entfernen",
		"CONFIGLISTFOR": "Konfigurationenfolge(n) für:",
		"SIMULATION": "Simulation",
		"TRANSFORMATION": "Transformieren",
		"INPUTWORD": "Eingabewort",
		"RANDOMINPUTWORD": "Zufallseingabewort",
		"STARTSIMULATION": "Simulation starten",
		"PAUSESIMULATION": "Simulation anhalten",
		"CONTINUESIMULATION": "Simulation fortsetzen",
		"RESTARTSIMULATION": "Simulation zurücksetzen",
		"FAST": "Schnell",
		"SLOW": "Langsam",
		"LASTINPUTS": "Letzte Eingabewörter:",
		"STATENAME": "Name",
		"ERRORHINT": "Der Automat enthält Fehler. Bitte korrigieren!",
		"SIMULATIONTERMINATEDSTEPS": "Mehr als {{STEPS}} Schritte wurden simuliert. Simulation wird abgebrochen.",
		"SIMULATIONTERMINATEDMACHINES": "Mehr als 50 Maschinen wurden simuliert. Suche wird abgebrochen.",
		"CLICKTARGETSTATE": "Klicke den Zielzustand an.",
		"CLICKSOURCESTATE": "Klicke den Zustand an, von dem der Übergang ausgehen soll.",
		"TRANSFORM": {
			"COMPLETEDEA": "Automat vervollständigen",
			"COMPLETEDEAHINT": "Beschreibung zur Vervollständigung DEA",
			"NEAWITHOUTEPSILON": "In NEA ohne ε transformieren",
			"NEAWITHOUTEPSILONHINT": "Beschreibung zu NEA ohne ε Transformation",
			"NEATODEA": "NEA in DEA",
			"NEATODEAHINT": "Beschreibung zu NEA zu DEA Transformation",
			"DEATONEA": "DEA in NEA",
			"DEATONEAHINT": "Beschreibung zu DEA zu NEA Transformation",
			"OPTIMIZENEA": "NEA vereinfachen",
			"OPTIMIZENEAHINT": "Beschreibung zu NEA Vereinfachung",
			"7TO6TUPLENKA": "7 in 6 Tupel NKA umwandeln",
			"7TO6TUPLENKAHINT": "Fügt einen neuen Start und Endzustand und ein neues Kellervorbelegungszeichen ein. Der Automat besitzt nur noch einen Endzustand. Würde man diesen streichen, enstpricht der Automat einer 6-Tupel Definition. FLACI simuliert jedoch immer die 7-Tupel Variante.",
			"TOGRAMMAR": "Automat zu kfG",
			"TOGRAMMARHINT": "Beschreibung zu Grammatik konvertieren",
			"MINIMALDEA": "DEA minimieren",
			"MINIMALDEAHINT": "Beschreibung zu Minimal-DEA Transformation",
			"COMBINETWOEA": "Automaten kombinieren",
			"COMBINETWOEAHINT": "Den aktuellen Automaten mit einem anderen endlichen Automaten verbinden. Nur Wörter die von beiden Automaten akzeptiert werden, werden auch vom entstehenden Automaten akzeptiert werden.",
			"EATOREGEXP": "Regulärer Ausdruck anzeigen",
			"EATOREGEXPTEXT": "Ein möglicher regulärer Ausdruck, der die gleiche Sprache beschreibt:<br><br>{{REGEXP}}",
			"DOWNLOADGRAPHSVG": "Graph als SVG herunterladen",
			"DOWNLOADGRAPHPNG": "Graph als PNG herunterladen",
			"TRANSFORMTOLATEX": "Automat für LaTeX konvertieren",
			"TRANSFORMTOLATEXTEXT": "Verwende den nachfolgenden Code in LaTeX und binde das Package <a href='https://github.com/TrueRushHunt3r/FLaAL' target='_blank'>FLaAL</a> ein.<br><br>{{CODE}}"
		}
	},
	"TDIAG": {
		"MYDIAGRAMS": "Meine Diagramme",
		"CREATENEWDIAGRAM": "Neues Diagramm erstellen",
		"CREATEDIAGRAM": "Diagramm erstellen",
		"DELETEDIAGRAM": "Diagramm löschen?",
		"DELETEDIAGRAMASK": "Möchten Sie das Diagramm: {{NAME}} wirklich löschen?",
		"EDITDIAGRAM": "Diagramm bearbeiten",
		"PUBLISHTO": "Diagramm veröffentlichen in",
		"COMPILERLIST": "Übersetzerliste",
		"TESTCOMPILER": "Übersetzer testen",
		"TESTSCANNER": "Scanner testen",
		"PARSERTABLE": "Parser Tabelle",
		"COMPILERURL": "Übersetzer-URL",
		"COPYCOMPILERURLSUCCESS": "Die URL des gewählten Übersetzers wurde in die Zwischenablage kopiert. Verwenden Sie diese in externen Web-Projekten über ein JavaScript src Tag oder in einem anderen FLACI-Projekt.",
		"IMPORTCOMPILER": "Importieren über Übersetzer-URL",
		"INPUT": "Eingabe:",
		"OUTPUT": "Ausgabe:",
		"GENERATOR": "Generator",
		"ADDRULE": "Neue Regel",
		"ADDTOKEN": "Neues Token",
		"ADDELEMENTRHS": "Element hinzufügen",
		"ADDRHS": "Alternative hinzufügen",
		"COMPILE": "Compile",
		"SCAN": "Scan",
		"SELECTCOMPILER": "Compiler auswählen",
		"SELECTINTERPRETER": "Interpreter auswählen",
		"PROGRAM": "Programm",
		"IOBLOCK": "E/A",
		"PROGRAMCODE": "Programm-Quelltext",
		"COMPILERCODE": "Compiler-Quelltext",
		"INTERPRETERCODE": "Interpreter-Quelltext",
		"INPUTCODE": "Eingabe",
		"OUTPUTCODE": "Ausgabe",
		"TEMPORARYCODE": "Zwischenerzeugnis, wird nicht gespeichert.",
		"END": "Beenden",
		"SELECTNEWCOMPILER": "Neuer Compiler (mit TDL)",
		"SELECTNEWCOMPILERFROMG": "Neuer Compiler (mit TDL von Grammatik)",
		"SELECTNEWINTERPRETER": "Neuer Interpreter (mit TDL)",
		"SELECTNEWINTERPRETERFROMG": "Neuer Interpreter (mit TDL von Grammatik)",
		"USEVCCDEFONLY": "Nur VCC-Definition verwenden",
		"SHOWASHTML": "Als HTML anzeigen",
		"GLOBALCODE": "Globaler Code für semantische Regeln",
		"SATTRIBUTEFOR": "S-Attribut für",
		"NORUNNABLECONTENT": "Keine ausführbaren Bausteine gefunden",
		"LOGCOMPILERGENERATED": "Erzeuge Compiler {{COMPILER}}.",
		"LOGCOMPILERRUN": "Der Compiler {{COMPILER}} wird ausgeführt.",
		"LOGINTERPRETERRUN": "Der {{INTERPRETER}} Interpreter wird ausgeführt.",
		"LOGOUTPUTCOMPILERVCC": "{{COMPILER}} Compiler in JS",
		"LOGOUTPUTINTERPETERVCC": "{{INTERPRETER}} Interpreter in JS",
		"LOGUSEIO": "Verwende {{NAME}} als Eingabe.",
		"LOGRUNPROGRAM": "{{NAME}} wird ausgeführt ...",
		"LOGWRITEIO": "Schreibe Ausgabe in Baustein {{NAME}}.",
		"LOGWRITECOMPILER": "Schreibe Ausgabe in Compiler-Baustein {{COMPILER}}.",
		"LOGWRITEINTERPRETER": "Schreibe Ausgabe in {{INTERPRETER}} Interpreter-Baustein.",
		"LOGWRITEPROGRAM": "Schreibe Ausgabe in Programm-Baustein {{PROGRAM}}.",
		"LOGCOMPILERUSE": "Verwende Compilerdefinition {{COMPILER}} als Eingabe.",
		"LOGINTERPRETERUSE": "Verwende {{INTERPRETER}} Interpreterdefinition als Eingabe.",
		"LOGPROGRAMUSE": "Verwende Programm {{PROGRAM}} als Eingabe.",
		"LOGRUNELEMENT": "{{NAME}} wird ausgeführt ...",
		"LOGGENERATEDSUCCESSFUL": "Erfolgreich erstellt.",
		"COMPONENTS": "Bausteine:",
		"ELEMENT": "Element:",
		"EDITELEMENT": "Bearbeiten",
		"SELECTELEMENT": "Auswählen",
		"COPYELEMENTS": "Kopieren",
		"COPY": "Kopie",
		"DELETEELEMENTS": "Löschen",
		"DOWNLOADASFILE": "Als Datei Herunterladen",
		"COMMENT": "Kommentar",
		"COMPONENTCOMPILER": "Compilerbaustein",
		"COMPONENTINTERPRETER": "Interpreterbaustein",
		"COMPONENTPROGRAM": "Programmbaustein",
		"COMPONENTIO": "Ein-/Ausgabebaustein",
		"SELECTEDELEMENT": "Ausgewählt:",
		"INPUTLANGUAGE": "Eingabesprache",
		"OUTPUTLANGUAGE": "Ausgabesprache",
		"WRITTENIN": "Geschrieben in",
		"INTERPRETS": "Interpretiert",
		"NOTRUNABLE": "nicht lauffähig",
		"RUNABLEON": "lauffähig",
		"FROMURL": "von URL laden (optional)",
		"RELOADFROMURL": "neu von URL laden",
		"RUN": "Ausführen"
	},
	"MENUCHANGE": "Ändern",
	"MENUDUPLICATE": "Duplizieren",
	"MENUPUBLISH": "Veröffentlichen",
	"MENUUNPUBLISH": "Zurückziehen",
	"MENULINK": "Weblink",
	"MENUDELETE": "Löschen",
	"MENUDOWNLOAD": "Exportieren",
	"OPENFILE": "Datei öffnen",
	"WEBLINK": "Weblink:",
	"COPYTOCLIPBOARD": "In Zwischenablage kopieren",
	"MAKEANOTHERCOPY": "Kopie erstellen",
	"USEEXISTINGCOPY": "weiterarbeiten",
	"ASKMAKEANOTHERCOPY": "Sie haben diesen Inhalt bereits verwendet.<br> Möchten Sie eine weitere Kopie erstellen,<br> oder mit Ihrer letzten Version weiterarbeiten?",
	"ERRORS": {
		"SERVERERROR": "Verbindungsfehler aufgetreten.",
		"LOGINFAILED": "Anmeldung fehlgeschlagen.",
		"EMAILUNKNOWN": "Email nicht bekannt.",
		"INVALIDEMAIL": "Geben Sie eine gültige Emailadresse ein.",
		"NOEMAIL": "Keine Email eingegeben.",
		"EMAILTOKENMISSMATCH": "Der Link ist nicht mehr gültig.",
		"PASSWORDTOOSHORT": "Das eingegeben Passwort ist zu kurz (mindestens 5 Zeichen).",
		"PASSWORDSNOMATCH": "Die \"Passwörter\" stimmen nicht überein.",
		"ERRORCREATINGAUTOMATON": "Der Automat konnte nicht angelegt werden.",
		"NOREGEXP": "Kein gültiger regulärer Ausdruck",
		"NODEA": "Kein deterministischer endlicher Automat.",
		"NOEA": "Kein endlicher Automat.",
		"NOKA": "Kein Kellerautomat.",
		"AUTOMATONERRORS": "Der Automat enthält noch Fehler. Bitte zuerst korrigieren.",
		"TOOMANYCHARSTRANSITION": "{{CHAR}} mehrfach in Übergängen von {{STATE}} verwendet.",
		"MISSINGCHARTRANSITION": "Am Zustand {{STATE}} ist kein Übergang mit {{CHAR}} vorhanden.",
		"EMPTYTRANSITION": "Der Automat benötigt mindestens ein Zeichen an jedem Übergang.",
		"MULTIPLEUSETRANSITION": "Der Übergang ({{STACK}},{{CHAR}}) wird an {{STATE}} mehrfach verwendent.",
		"NEEDFINALSTATE": "Der Automat sollte zunächst mindestens einen Endzustand haben.",
		"NOFINALSTATE": "Der Automat hat keinen Endzustand.",
		"LALR1GENERATORCONFLICTS": "Bei der Erzeugung des entsprechenden LALR(1)-Parsers ist ein Konflikt aufgetreten.",
		"AUTOMATONTYPENOTSUPPORTED": "Dieser Automatentyp wird von FLACI nicht unterstützt. Der Automat kann nciht importiert werden.",
		"NOVALIDAUTOMATONFILE": "Die angegebene Datei ist keine gültige Automatendefinition.",
		"NOVALIDGRAMMARFILE": "Die angegebene Datei ist keine gültige Grammatikdefinition.",
		"NOVALIDDIAGRAMFILE": "Die angegebene Datei ist keine gültige Diagrammdefinition.",
		"FILEREADERROR": "Fehler beim Lesen der Datei."
	},
	"PASSWORTEMAILSUBJECT": "FLACI-Passwort vergessen",
	"PASSWORTEMAILBODY": "Liebe(r) Nutzende(r),\n\neine Anfrage zum Zurücksetzen des Passworts wurde gestellt. Wenn Sie diese Anfrage nicht selbst gestellt haben, können Sie diese E-Mail ignorieren. Wenn Sie jetzt Ihr Passwort bei FLACI zurücksetzen möchten, klicken Sie auf den nachfolgenden Link oder kopieren Sie diesen in Ihren Browser.\n\n{{LINK}}\n\nViele Grüsse,\nIhr FLACI-Team",
	"DELETEACCOUNTEMAILSUBJECT": "FLACI-Account gelöscht",
	"DELETEACCOUNTEMAILBODY": "Liebe(r) Nutzende(r),\n\nIhr Konto für {{EMAIL}} wurde erfolgreich auf FLACI.com gelöscht.\n\nViele Grüsse,\nIhr FLACI-Team",
	"SENDCONFIRM": "Die E-Mail wurde verschickt. Bitte prüfen Sie auch Ihren Spam-Ordner."
}