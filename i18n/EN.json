{
	"IMPRESS": "About",
	"LOGIN": "Login",
	"LOGOUT": "Logout",
	"HOME": "Home",
	"USERACCOUNT": "Account",
	"CONTACT": "Contact",
	"MODULELANGUAGES": "Formal languages",
	"MODULEKFGEDIT": "Context-free grammars",
	"MODULEREGEXPEDIT": "Regular expressions",
	"MODULEAUTOEDIT": "Abstract automata",
	"MODULETDIAG": "Compilers and interpreters",
	"EXAMPLECOLLECTION": "Examples",
	"ADMINISTRATION": "Admin",
	"CANCEL": "Cancel",
	"SAVE": "Save",
	"DELETE": "Delete",
	"FOLDER": "Folder",
	"NEWFOLDER": "New Folder",
	"FOLDERNAME": "Foldername",
	"PUBLISH": "Publish",
	"MAKECOPY": "Make a copy",
	"PUBLICCOLLECTION": "Public collection",
	"FORGOTPASSWORD": "Forgot your password?",
	"EMAIL": "Email",
	"PASSWORD": "Password",
	"PASSWORDREPEAT": "Reenter your password",
	"NEWPASSWORD": "New password",
	"SAVEPASSWORD": "Save password",
	"RESETPASSWORD": "Reset password",
	"REGISTERNEW": "Register account",
	"REGISTER": "Register",
	"NAME": "Name",
	"SURNAME": "Surname",
	"ALPHABET": "Alphabet",
	"HINT": "Hint",
	"DESCRIPTION": "Description",
	"RESULT": "Result",
	"ERROR": "Error",
	"UNDO": "Undo last change",
	"REDO": "Redo last change",
	"LASTCHANGE": "Last change",
	"MENUCHANGE": "Change",
	"MENUDUPLICATE": "Duplicate",
	"MENUPUBLISH": "Publish",
	"MENUUNPUBLISH": "Unpublish",
	"MENULINK": "Weblink",
	"MENUDELETE": "Delete",
	"PASSWORTEMAILSUBJECT": "Forgot FLACI password",
	"SENDCONFIRM": "The email was sent. Please check both your mailbox and also your spam folder.",
	"PASSWORTEMAILBODY": "Dear user,\n\na password reset request was made. If you did not initiate this request yourself, you can ignore this email. If you'd like to reset your password at FLACI now, click on the subsequent link or copy it into your browser:\n\n{{LINK}}\n\nKind regards,\nyour FLACI-Team",
	"BOOK": {
		"AUTHORS": "Autors: Wagenknecht, Christian / Hielscher, Michael",
		"CONTENTTEXT1": "The more abstract contents of theoretical computer science are motivated by practical examples out clearly taught and consolidated in exercises. The whole text of the book runs through the project to develop a compiler for a language for graphical effects. The necessary contributions are progressively created and aspects of automated compiler generation are discussed.",
		"TITLE": "Formal languages, abstract automata and compilers",
		"SUBTITLE": "Textbook for undergraduate studies",
		"CONTENT": "Contents",
		"CONTENTTEXT2": "For modeling of formal languages, regular expressions, abstract automata and for automated compiler generation from a graphic-visual description AtoCC provides mutual interconnected components. The learning and working environment AtoCC was developed specifically for the study of theoretical computer science and already successfully used at several universities and schools. AtoCC deepened theoretical knowledge through practical exercises and attractive application projects from the graphics and audio. Translation and processing more or less complicated languages, we now find, for example, also in modern web applications.",
		"TOPICS": "Topics",
		"TOPICSTEXT": "Structure of programs - Fundamental terms - Definitions of infinite sets - Compilers - Finite automata - Regular languages and regular expressions - Pushdown automata and context-free languages - LL(k) langauges - LR(K) languages - Parser and parser generators - Project on language translation - Mealy- and Moore machines - Turing machine and Chomsky-type-0/1 languages",
		"TARGET": "Target audience",
		"TARGETTEXT": "Computer science students at universities of applied science, mainly research oriented universities, and universities of cooperative education as well as teachers at extended secondary schools (gymnasia)."
	},
	"LANGUAGES": {
		"ALPHABETANDCHARACTERS": "Alphabet and symbol",
		"WORD": "Word",
		"DEFALPHABET": "An <i>alphabet</i> is any finite and non empty set of <i>symbols</i>.",
		"DEFWORD": "A <i>word w</i> over an <i>alphabet A</i> is a finite sequence, or string, of zero or more symbols taken from <i>A</i>. ε simply stands for the <i>empty word</i> \"\".",
		"NEXTTOWORD": "Continue to word",
		"ALHABETCHARS": "Enter symbols separated with commas.",
		"BUILDWORDHINT": "Repeatedly left-click a symbol to gradually construct a particular word.",
		"WORDSET": "Set of words",
		"LANGUAGE": "Language",
		"DEFLANGUAGE": "A <i>language L&sube;A<sup>*</sup></i> is a set of words over <i>A</i>. It is either a finite or a countable infinite set.",
		"DEFWORDSET": "The <i>set of words A<sup>*</sup></i> is the set of <i>all</i> words over an alphabet <i>A</i>, including the <i>empty word &epsilon;</i>.",
		"SELECTALPHABET": "Choose one of the alphabets as follows to experiment with.",
		"CREATESELF": "is defineable by the learner.",
		"DELETECHARSHINT": "Left-click a symbol to remove it.",
		"NEXTTOWORDLENGTH": "Continue to set of words",
		"DEFWORDLENGTH": "The <i>length of a word w</i>, |<i>w</i>| for short, is the number of symbols in it.",
		"WORDLENGTH": "Length of the word",
		"SHOWMOREITEMS": "Show more items",
		"NEXTTOLANGUAGE": "Continue to language",
		"BUILDLANGUAGEHINT": "Form a language <i>L</i> by left-clicking of some particular words of <i>A<sup>*</sup></i>.",
		"DEFLANGUAGELIMITS": "Formal languages which are provided for practical applications are usually countable infinite. How can they be definined?",
		"ALTERNATIVEHINT": "Some countable infinite languages can be definied for example as follows",
		"ALLWORDSSTARTINGWITH": "<i>L<sub>1</sub></i> = all words of <i>A<sup>*</sup></i> that start with the symbol",
		"ALLWORDSSTARTINGWITHEND": ".",
		"ALLWORDSSHORTERTHEN": "<i>L<sub>2</sub></i> = all words of <i>A<sup>*</sup></i> whose lengths are less than or equal",
		"ALLWORDSSHORTERTHENEND": ".",
		"ALLWORDSCONTAINING": "<i>L<sub>3</sub></i> = all words of <i>A<sup>*</sup></i> that contain",
		"ALLWORDSCONTAININGEND": "as a subword.",
		"ALLWORDSSAMEAMOUNT": "<i>L<sub>4</sub></i> = all words of <i>A<sup>*</sup></i> that contain the same number of",
		"ALLWORDSSAMEAMOUNTAND": "and",
		"ALLWORDSSAMEAMOUNTEND": "."
	},
	"REGEXPEDIT": {
		"RAILROAD": {
			"TITLE": "Syntax-Diagram",
			"NONEOF": "None of:",
			"ONEOF": "One of:",
			"ANYCHARACTER": "any character",
			"STARTOFLINE": "Start of Line",
			"ENDOFLINE": "End of Line",
			"TIMES": "+ times",
			"UPTOTIMES": "upto {{TIMES}} times",
			"GROUP": "Group {{GROUP}}",
			"REFERENCEGROUP": "Back reference (Group {{GROUP}})"
		},
		"REFERENCE": {
			"R1": "Matches the single character a",
			"R2": "Matches the sequenz of the characters a b and c in this order",
			"R3": "Matches any of the alternatives specified",
			"R4": "Matches any character between the brackets",
			"R5": "Matches any character NOT between the brackets",
			"R6": "Matches a single digit",
			"R7": "Matches any character not a digit",
			"R8": "Matches at least one n or more occurrences of n",
			"R9": "Matches zero or more occurrences of n",
			"R10": "Matches zero or one occurrences of n",
			"R11": "Matches a single character, except newline or line terminator",
			"R12": "Matches the character [. Always escape special characters!",
			"R13": "Matches a word character",
			"R14": "Matches a non-word character",
			"R15": "Matches a digit",
			"R16": "Matches a non-digit character",
			"R17": "Matches a whitespace character",
			"R18": "Matches a non-whitespace character",
			"R19": "Matches a new line character",
			"R20": "Matches a carriage return character",
			"R21": "Matches a tab character",
			"R22": "Matches 2 to 4 occurrences of n",
			"TITLE": "Reference:"
		},
		"ISNOTREGULAR": "The expression does not describe a regular language. Transformation is not possible.",
		"REGEXP": "Regular Expression",
		"REGEXPFORL": "Regular expression for L",
		"REGEXP2": "Regular expression for L2",
		"OPENIN": "Open in Regexp Editor",
		"COMPAREREGEXP": "Compare regular expressions",
		"EQUALREGEXP": "The regular expressions for L and L2 are equivalent.",
		"NOTEQUALREGEXP": "The regular expressions for L and L2 are NOT equivalent.",
		"GRAMMAR": "Grammar",
		"SEARCHTEXT": "search text",
		"DEFINITION": "Definition",
		"GRAMMARNAME": "grammar name",
		"EXPERIMENT": "Experiment",
		"DEFREGEXP": "<i>Regular expressions</i> are a compact notation for regular languages. <i>Regular expressions</i> are widely used in text editors and command line interfaces for searching and filtering text. In compiler comstruction regular expressions are used to define <i>tokens</i> like numbers, identifiers or keywords.",
		"RANDOMWORDS": "Generate random word from L.",
		"SAVEASGRAMMAR": "Save as context free grammar",
		"SAVEASREGRAMMAR": "save as regular grammar",
		"SAVEASNEA": "save as automaton",
		"INTRODUCTION": "Here we use <i>regular expression</i> as a pattern for words that are part of a <i>regular grammar</i>. On the left side the <i>regular expression</i> is shown that matches the red-marked words on the right side of the screen. A <i>Syntax diagram</i> is shown that describes the language defined by the regular expression.",
		"DEFSINGLECHARS": "The simplest regex <i>a</i> defines the one-character word \"a\", in short: a. It is one letter a. This regex defines language L = {a}.<br>A regex can be <i>concatenated</i>: <i>a</i> followed by <i>b</i>, followed by <i>c</i> can be written as <i>abc</i>.",
		"EXAMPLES": {
			"TEXT1": "Can you see how the defined language changes when you change the regular expression <i>a</i> into <i>ab</i> or <i>abc</i> ?",
			"TEXT2": "What is the regular expression that defines the language that contains the words <i>red</i>, <i>blue</i> and <i>yellow</i>?",
			"SAMPLETEXT2": "red\nblue\ngelb\nbrown\nyellow",
			"EXPRESSION2": "red|blue|yellow",
			"TEXT3": "Can you build a regular expression that matches the first three lines containing the word Gelb but not Rot? Hint: beware of the space character!",
			"EXPRESSION3": "Gelb ist eine( tolle)? Farbe",
			"TEXT4": "The following expression can be shortened using  <i>+</i> three times. How?",
			"TEXT5": "Multiple regular expressions can be joined together by concatenation. In the example, a sequence of three characters is searched for.<br>How must the character set be expanded so that the permissible words can also contain the capital letters R, O and T? Can you write a regular expression that describes only the last given input word by just adding characters and sets?",
			"TEXT6": "The sample expression describes the language of three-digit natural numbers. What does a regular expression for four-digit or five-digit numbers look like?",
			"TASK1": "Write a regular expression for HTML color codes<br>\n(Only 6-digit color codes that start with a # should be accepted.)",
			"TASK2": "Provide a regular expression for times<br>\n(Only valid times should be accepted.)",
			"TASK3": "Can you give a expression for German license plates<br>\ncontaining two upper case sets and a number<br>\n(Only the first three lines should be accepted.)",
			"TASK4": "Write a regular expression for valid email addresses<br>\n(Only the 2nd and third line, valid email addresses should be accepted.)",
			"SAMPLETASK3": "NOL DE 2034\nZI A 23\nB HU 874\nWRONG 129\nNO NO NO"
		},
		"DEFALTERNATIVE": "A vertical bar | (pronounced as \"OR\") defines two alternative regular expressions. <br><i>Katze</i>|<i>Maus</i> defines language L = {Katze, Maus}. More alternatives can be added:  <i>aaa</i>|</i>bbb</i>|</i>ccc</i>.<br>The order of the alternatives does not matter: <i>aaa</i>|<i>bbb</i> = <i>bbb</i>|<i>aaa</i>.<br>Note: concatenation has precedence and will be done first. To change precedence, use parenthesis: <i>(Ha</i>|<i>Ma)us</i> differs from <i>Ha|Maus</i>.",
		"DEFOPTIONAL": "A question mark defines something as optional: one or none.<br>Note: optional has precedence over concatenation.<br> <i>Haus?</i> defines L = {Hau, Haus}.<br>Parentheses can define more complex regular expressions: <i>das (blaue|rote )?Tuch</i>.",
		"DEFSTAR": "<i>a*</i> means that <i>a</i> can occur 0 or more times: <i>&epsilon;</i>, <i>a</i> , <i>aa</i>, ....<br>If at least one character must be present then instead of <i>aa*</i> the shorter  <i>a+</i> can be used.<br>Note: These operators have priority over concatenation. <i>Haus*</i> defines L = {Hau, Haus, Hauss, Hausss, ...}.<br>Use parentheses for more complex expressions. <br><i>(abc)+</i> defines languages of the form <i>abc</i>, <i>abcabc</i>, <i>abcabcabc</i> etc.",
		"DEFCLASSES": "The expression <i>[abc]</i> is a CharacterSet and defines a set from where exactly one character can be chosen.<br>The order in the set is not important: <i>[abc]</i> = <i>[cab]</i>.<br>Note: <i>[Handy]</i> will not match the word Handy, but instead every single character H, a, n, d or y.",
		"DEFCLASSRANGE": "In character classes like [a-z], [a-zA-F] or [0-9], whole ranges of characters can be specified.<br>\nThe minus sign has the meaning of an enumeration and if it is literally part of the language it must be at the end or beginning like [abc-].",
		"DEFSPECIALCHARS": "Now you know the most important notations for regular expressions. However, there are many other operations that are not mentioned here.\nIf you are looking for special characters such as *, +, ?, [], (), $, in the word, you must put a \\ in front: 5\\+3, 50\\$ etc. to switch off their special function.<br><br>\nHere are some practice examples for constructing regular expressions."
	},
	"KFGEDIT": {
		"CREATENEWGRAMMAR": "Create new grammar",
		"EDITGRAMMAR": "Edit grammar",
		"PUBLISHTO": "Publish grammar",
		"HASSTILLERRORS": "The grammar is still incomplete.",
		"ISLEFTREGULAR": "The grammar is left-linear.",
		"ISRIGHTREGULAR": "The grammar is right-linear.",
		"ISNOTREGULAR": "The grammar is not regular.",
		"CANNOTTRANSORMWITHOUTREGULAR": "The grammar is not regular. Therefore, it can not be transformed into a NFA.",
		"TOOMANYTREES": "There are more than one, possibly infinitely many parse trees for the word <b>{{INPUT}}</b>.",
		"DERIVEERROR": "The word <b>{{INPUT}}</b> could not be derived.",
		"DELETEGRAMMAR": "Delete grammar",
		"DELETEGRAMMARASK": "Do you really want to delete the grammar {{NAME}}?",
		"MYGRAMMARS": "My grammars",
		"PRODUCTIONS": "production rules",
		"HOWTO": "<b>Here is how a grammar has to be defined in FLACI: </b><br>\n<ul>\n<li>Note the production rules.</li>\n<li>Terminal symbols <i>may be</i> included with ' (like <tt>'pi'</tt>). Wheras the terminal symbols are colored in blue the nonterminals are in red.</li>\n<li>By convention, the left-sided nonterminal of the first rule is the start symbol of the grammar.</li>\n<li>Consider for example a grammar of palindromes over {a,b}*:<br> S -&gt; a | b | EPSILON | a S a | b S b</li>\n<li>Write EPSILON for &epsilon;:<br> S -&gt; EPSILON | a</li><li>The dot notation (ellipsis) reduces the effort for writing of all rules.: <br>a ... z | 0 ... 9.</li></ul>",
		"VALIDGRAMMAR": "Valid grammar",
		"FULLGRAMMAR": "Complete grammar",
		"RENAMENONTERMINAL": "Rename nonterminal",
		"OLDNONTERMINAL": "current nonterminal",
		"NEWNONTERMINAL": "new nonterminal",
		"DERIVE": "derive",
		"RANDOMWORD": "Generate a random word of L(G) to parse",
		"SINGLESTEP": "single step mode",
		"CHECK": "check",
		"TRANSFORMATIONS": "Transf.",
		"TREESELECT": "Parse tree  {{INDEX}} of {{TOTAL}} in total",
		"SATZFORM": "sentential form",
		"USEDRULE": "applied rule",
		"CONVERTS": "Convert",
		"CONVERT": {
			"TONEA": "Transform into NFA",
			"TONEAHINT": "Transforms a regular gammar into an equivalent nondeterministic finite automaton.",
			"TONKA": "Transforms into NPDA",
			"TONKAHINT": "Transforms a context-free grammar into an equivalent nondeterministic pushdown automaton."
		},
		"TRANSFORM": {
			"CHECKLL1": "LL(1) grammar?",
			"CHECKLL1HINT": "<ul>\n<li>Requirement 1: The FIRST sets of all sentential forms representing the right hand side of the rules for a selected nonterminal have to be pairwise disjoint.</li>\n<li>Requirement 2: For each nonterminal that can be derived to ɛ whose FIRST set and FOLLOW set have to be disjoint.</li>\n</ul>",
			"ISREGULAR": "Regular Grammar?",
			"ISREGULARHINT": "It checks if all production rules of the grammar are either in the form X &rarr; aY (right-linear) or on X &rarr; Ya (left-linear). In addition, terminal-generating rules are permitted.",
			"TOCNF": "Chomsky normal form",
			"TOCNFHINT": "<ul>\n<li>A context-free grammar G is said to be in Chomsky normal form (CNF) if all productions are in one of two simple forms, either:\n<ol>\n<li>A &rarr; a, where A is nonterminal and 'a' is a terminal and A, or</li>\n<li>A &rarr; BC, where A, B, and C are each nonterminals. </li>\n</ol>\n</li>\n<li>To put a CFG in CNF start with a grammar that has no ɛ-rules, unit productions, or useless symbols.</li>\n<li>Arrange that all sentential forms of length 2 or more on the right hand sides of all rules consist only of nonterminals.</li>\n<li>For rules with a right hand sides length of 3 or more substitute a cascade of productions with exactly two nonterminals one their right hand.</li>\n</ul>",
			"INSERTEPSILON": "Add ε-rules",
			"INSERTEPSILONHINT": "To add ε to the CFL L(G) you have \n<ul>\n<li>to introduce a new nonterminal s' to be the new start symbol of G and</li>\n<li>to add two new rules for s', namely s' &rarr; s | ε, where s is the previous start symbol of G.</li>\n</ul>",
			"REMOVEEPSILON": "Remove ε-rules",
			"REMOVEEPSILONHINT": "<ul>\n<li>Find all m nonterminals A which are nullable, i.e., A *&rArr; ɛ.</li>\n<li>For all rules that contain one ore more nullable symbols on their right-hand side substitute the productions with all 2<sup>m</sup> possible combinations of the given sentential form where nullable symbols are present or absent.</li>\n</ul>",
			"SIMPLIFY": "Remove useless nonterminals",
			"REMOVELOOPS": "Remove unit productions",
			"SIMPLIFYHINT": "<ul>\n<li>Nonterminals that are not reachable from the start symbol of the grammar will be removed.</li>\n<li> ... </li>\n<ul>",
			"REMOVELOOPSHINT": "<ul>\n<li>Prepare all pairs of nonterminals (A,B), where A*&rBrr; B.</li>\n<li>All productions for B are assigned to A, except for rules B &rarr; X, where X is a single nonterminal on the right.</li>\n</ul>",
			"REMOVELEFTREC": "Remove left recursion",
			"REMOVELEFTRECHINT": "<ul>\n<li>Apply the Paull's algorithm to a CFG without both ɛ-rules and unit productions.</li>\n</ul>",
			"LEFTFACTOR": "Left factoring",
			"LEFTFACTORHINT": "The longest common prefix &alpha; of all sentential forms for a certain nonterminal X will be excluded, like this: X &rarr;\t&alpha; X', where X' defines the respective rest of the sentential form behind &alpha;."
		},
		"LL1": {
			"TITLE": "Check of the LL(1) requirements",
			"F1": "Requirement 1",
			"F2": "Requirement 2",
			"F1OK": "Requirement 1 fulfilled",
			"F2OK": "Requirement 2 fulfilled",
			"F1NOTOK": "Requirement 1 is not satisfied.",
			"F2NOTOK": "Requirement 2 is not  satisfied.",
			"TRUE": "fulfilled",
			"FALSE": "not satisfied",
			"EMPTYFIRST": "An empty FIRST-set is prohibited.",
			"NOEPSILON": "Because ɛ is not an item of the FIRST-set, the requirement 2 is fulfilled automatically."
		},
		"GRAMMAR": "Grammar",
		"DIAGRAMMODE": "Syntax diagram",
		"TEXTMODE": "Text mode",
		"SHOWDERIVATIONLIST": "Show derivation list",
		"NEWTERMINAL": "new terminal"
	},
	"BOOKTAB": "Book",
	"ABOUT": {
		"FLACILIBS": "Used libraries",
		"FLACI": "FLACI: what's all about?",
		"FLACITEXT": "FLACI (short hand for formal languages, automata, compilers, and interpeters) is a learning environment for teaching selected theoretical aspects of computer science in particular the theory of formal languages, theory of automata, and applications in the field of compiler construction. FLACI supports activities to acquire techniques of abstraction as they are increasingly used in both professional software development and high level programming concepts.",
		"FLACIREF": "FLACI is a joint research project of the <a href=\"http://www.hszg.de/\" target=\"_blank\">Hochschule Zittau/Görlitz</a> and the <a href=\"http://www.phsz.ch/\" target=\"_blank\">Pädagogische Hochschule Schwyz</a>.",
		"FLACIBASE": "FLACI is based on experiences gained from the previous tool <a href=\"http://atocc.de/\" target=\"_blank\">AtoCC</a> from the year 2012 and running on the desktop.",
		"FLACIAUTHORS": "Project management: <a href=\"https://www.phsz.ch/forschung/institut-fuer-medien-und-schule/michael-hielscher/\" target=\"_blank\">Dr. Michael Hielscher</a> and <a href=\"https://www.hszg.de/f-ei/fakultaet/professoren/christian-wagenknecht\" target=\"_blank\">Prof. Dr. Christian Wagenknecht</a>",
		"FLACISTUDENTS": "Students who contributed to the project (names are listed in alphabetical order)",
		"FLACISTUDENTLIST": "Stefan Bradl, Ronald Krause, Dana Müller, Alexander Preuß, Robert Rosenberger, Tobias Salzmann, Robert Stricker, Ralf Zücker"
	},
	"OK": "OK",
	"ALPHABETS": "Alphabets",
	"WEBLINK": "Weblink:",
	"COPYTOCLIPBOARD": "Copy to clipboard",
	"MAKEANOTHERCOPY": "create another copy",
	"USEEXISTINGCOPY": "continue work",
	"ASKMAKEANOTHERCOPY": "You have already used this content.<br> Would you like to create another copy,<br> or continue your work from last time?",
	"ERRORS": {
		"SERVERERROR": "Internet connection error.",
		"LOGINFAILED": "Login failed."
	},
	"AUTOEDIT": {
		"TYPE": "Type",
		"TYPEDEASHORT": "DFA",
		"TYPENEASHORT": "NFA",
		"TYPEMEALYSHORT": "MEALY",
		"TYPEMOORESHORT": "MOORE",
		"TYPEDEA": "deterministic finate automaton",
		"TYPENEA": "nondeterministic finate automaton",
		"TYPEMEALY": "Mealy-Machine",
		"TYPEMOORE": "Moore-Machine",
		"DELTATABLE": "transition table",
		"DEFINITION": "Definition",
		"CONVERTS": "Convert",
		"TRANSFORMATIONS": "Transform",
		"MYAUTOMATA": "My automatons",
		"CREATENEWAUTOMATON": "Create New Automaton",
		"EDITAUTOMATON": "Edit Automaton",
		"DELETEAUTOMATON": "Delete Automaton",
		"INPUTALPHABET": "Input Alphabet",
		"AUTOLAYOUTGRAPH": "AutoLayout",
		"CHECKAUTOMATON": "Check",
		"CHECKOK": "The Automaton is correct",
		"SELECTALL": "all",
		"SELECTNONE": "none",
		"INPUT": "Input",
		"OUTPUT": "Output",
		"READ": "Read",
		"WRITE": "Write",
		"DIRECTION": "Direction",
		"DELETETRANSITION": "Delete transition",
		"FINALSTATE": "Final state",
		"STARTSTATE": "Start state",
		"DELETESTATE": "Delete state",
		"SIMULATION": "Simulation",
		"STARTSIMULATION": "Start simulation",
		"CREATENEWTRANSITION": "New transition",
		"CREATENEWSTATE": "New state",
		"INITIALTAPECHAR": "Initial tape char",
		"INITIALSTACKCHAR": "Initial stack char",
		"TAPE": "Tape",
		"STACK": "Stack",
		"TRANSFORMATION": "Transform",
		"INPUTWORD": "Input word",
		"RANDOMINPUTWORD": "Random inputword",
		"TRANSFORM": {
			"COMPLETEDEA": "Complete DFA",
			"COMPLETEDEAHINT": "Complete DFA hint",
			"NEAWITHOUTEPSILON": "Transorm to NFA without ε",
			"NEAWITHOUTEPSILONHINT": "Hint transform to NFA without ε",
			"NEATODEA": "NFA to DFA",
			"NEATODEAHINT": "Hint transorm NFA to DFA",
			"DEATONEA": "DFA to NFA",
			"TOGRAMMAR": "Automaton to grammar",
			"MINIMALDEA": "Minimize DFA",
			"DEATONEAHINT": "DFA to NFA hint",
			"OPTIMIZENEA": "Optimize NFA",
			"OPTIMIZENEAHINT": "Optimize NFA hint",
			"7TO6TUPLENKA": "7 to 6 tuple PDA",
			"7TO6TUPLENKAHINT": "Adds a new start and final state and a new PDA symbol. The automaton has only one final state. If you deleted this, the machine corresponds to a 6-tuple definition. However, FLACI always simulates the 7-tuple variant.",
			"TOGRAMMARHINT": "Convert to grammar hint",
			"DOWNLOADGRAPHSVG": "Download graph as SVG",
			"DOWNLOADGRAPHPNG": "Download graph as PNG",
			"TRANSFORMTOLATEX": "Convert automaton to LaTeX",
			"TRANSFORMTOLATEXTEXT": "Use this Code in LaTeX and bind package <a href='https://github.com/TrueRushHunt3r/FLaAL' target='_blank'>FLaAL</a> ein.<br><br>{{CODE}}",
			"EATOREGEXPTEXT": "One possible regexp that defines the same language:<br><br>{{REGEXP}}",
			"EATOREGEXP": "Show regular expression",
			"MINIMALDEAHINT": "minimize DFA hint"
		},
		"TYPEDKASHORT": "DPA",
		"TYPENKASHORT": "NPA",
		"TYPEDKA": "deterministic pushdown automaton",
		"TYPENKA": "nondeterministic pushdown automaton",
		"TYPETMSHORT": "TM",
		"TYPETM": "deterministic Turing Machine",
		"ALLOWPARTIAL": "allow δ as partial function",
		"ALLOWPARTIAL2": "allow δ and λ partial functions",
		"ASKREMOVETRAPSTATES": "Remove trap states?",
		"COPYTRANSITIONTABLE": "copy transition table",
		"TAPEALPHABET": "Tape alphabet",
		"STACKALPHABET": "PA alphabet",
		"ALHABETCHARS": "Alphabet characters (comma separated)",
		"CREATEALPHABET": "create alphabet",
		"PUBLISHTO": "publish automaton to",
		"DELETEAUTOMATONASK": "Really delete automaton {{NAME}} ?",
		"DEFMOORE": "A <i>Moore Machine</i> is defined by a 6-tuple  <i>M = (Q,Σ,∆,δ,λ,q&#8320;)</i>.<br>\n<br>\nThe meaning of the symbols:<br>\nQ ... the set of states<br>\nΣ ... the input alphabet<br>\n∆ ... the output alphabet<br>\nδ ... the transition (delta) function<br>\n<span style=\"padding-left:2em\"></span> Q x Σ → Q<br>\nλ ... output function<br>\n<span style=\"padding-left:2em\"></span> Q → ∆<br>\nq&#8320;... starting state, q&#8320; ∈ Q<br>\n<br>\nThis  automaton produces output on every transition.",
		"DEFDEA": "A <i>deterministic finate automaton </i>in short: DFA or FA is defined by a 5-tuple <i>M = (Q,Σ,δ,q&#8320;,E)</i>.<br>\n<br>\nMeaning of the symbols:<br>\nQ ... finate set of states<br>\nΣ ... input alphabet<br>\nδ ... transition function<br>\n<span style=\"padding-left:2em\"></span> Q x Σ → Q<br>\nq&#8320;... starting state, q&#8320; ∈ Q<br>\nE ... set of final states, E ⊆ Q<br>\n<br>\nThe automaton accepts when reaching a final state at the end of the input word.",
		"PAUSESIMULATION": "Pause simulation",
		"CONTINUESIMULATION": "Continue simulation",
		"RESTARTSIMULATION": "Restart simulation",
		"FAST": "Fast",
		"SLOW": "Slow",
		"LASTINPUTS": "Last inputs:",
		"STATENAME": "Name",
		"LEFT": "Left",
		"RIGHT": "Right",
		"NONE": "None",
		"DEFNEA": "EA <i>nondeterministic finate automaton</i>, short: NFA, is defined by a 5-tuple <i>M = (Q,Σ,δ,q&#8320;,E)</i>.<br>\n<br>\nMeaning of the symbols:<br>\nQ ... finate set of states<br>\nΣ ... input alphabet<br>\nδ ... transition function<br>\n<span style=\"padding-left:2em\"></span> Q x (Σ ∪ {ε}) → &weierp;(Q)<br>\nq&#8320;... starting state, q&#8320; ∈ Q<br>\nE ... set of final states, E ⊆ Q<br>\n<br>\nThe automaton accepts when reaching a final state at the end of the input word.",
		"DEFMEALY": "A <i>Mealy Machine</i> is defined by a 6-tuple  <i>M = (Q,Σ,∆,δ,λ,q&#8320;)</i>.<br>\n<br>\nThe meaning of the symbols:<br>\nQ ... the set of states<br>\nΣ ... the input alphabet<br>\n∆ ... the output alphabet<br>\nδ ... the transition (delta) functions<br>\n<span style=\"padding-left:2em\"></span> Q x Σ → Q<br>\nλ ... output function<br>\n<span style=\"padding-left:2em\"></span> Q → ∆<br>\nq&#8320;... starting state, q&#8320; ∈ Q<br>\n<br>\nThis  automaton produces output on every transition."
	},
	"OPENFILE": "Open file",
	"MENUDOWNLOAD": "Download",
	"SEARCH": "Search",
	"YES": "Yes",
	"NO": "No",
	"PASSWORDNOW": "Current password",
	"CHANGEEMAIL": "Change email",
	"CHANGEPROFILE": "Change profile",
	"CHANGEPASSWORD": "Change password",
	"DELETEACCOUNTEMAILSUBJECT": "FLACI account deleted",
	"DELETEACCOUNTEMAILBODY": "Dear User,\n\nYour account for {{EMAIL}} on FLACI.com is removed.\n\nRegards,\nThe FLACI-Team"
}